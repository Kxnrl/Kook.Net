---
uid: Guides.Entities.Casting
title: 类型转换
---

# 类型转换

通过类型转换，实体可以转换为其它定义下的实体，但这种转换仅能在有继承关系的变体间进行。
例如：`IUser` 可以转换为 `IGuildUser`，但不能转换为 `IMessage`。

> [!NOTE]
> 如果两个接口之间存在继承关系，它们便可以进行互相的转换。
> 将实体类转换为其所实现的接口也可以合法的。

## 向上类型转换

通过向上类型转换，实体可以被转换为更通用的变体，例如：将 `IGuildUser` 转换为 `IUser`。
尽管向上类型转换的结果往往具有更简化的信息，但由于多态性，基类类型的变量可以保存派生类型。
向上类型转换一般是隐式进行的。

通过向下类型转换，实体可以转换为包含更详细信息的变体，例如：将 `IUser` 转换为 `IGuildUser`，
这样便可以访问原始无法直接访问的信息。

## 向下类型转换

向下类型转换是访问实体的实际定义最直接的方式，如果要访问派生类型的实例成员，
可以直接进行向下类型转换。向下类型转换一般是显式进行的。

[!code-csharp[Up-casting and Down-casting](samples/updowncasting.cs)]

> [!WARNING]
> 作为一种强制类型转换操作，如果两种类型之间不兼容，向下类型转换可能会在执行时抛出
> `InvalidCastException` 异常，在这种情况下，通过模式匹配来进行类型转换可以有效地避免这种异常。

## 更一般的类型转换

更一般情况下的类型转换往往使用 `as` 运算符来向将对象转换为给定的类型。
如果实体确实能被转换为给定的类型，运算结果会返回转换后的类型，来让属性可以为访问。

[!code-csharp[Casting](samples/casting.cs)]

> [!WARNING]
> 如果类型转换的结果可能为 null，在访问其属性或方法时则会抛出 `NullReferenceException` 异常，
> 在这种情况下，通过模式匹配进行安全类型转换则更为实用，这可以阻止此异常的抛出。

## 安全类型转换

安全类型转换在转换前会进行模式匹配检查，因此可以保证转换结果类型永不为 null。

C# 提供了三种语法来进行安全类型转换：

### 类型检查

要进行安全类型转换，需要使用 `is` 运算符来检查值是否属于给定地类型。
如果检查不通过，条件判断语句可以绕过代码，来保证程序不会访问 null 对象的属性。

[!code-csharp[Casting Check](samples/casting-check.cs)]

### 结合声明的初始化赋值

这里，类型检查、类型声明、初始化赋值组合在一起，可以简化代码，
这样，在类型检查通过后，对象将会被立即转换并赋值到一个新的变量中。

[!code-csharp[Casting Declaration](samples/casting-declaration.cs)]

### 结合逻辑模式

在之前的示例中，我们通过类型检查来避免程序在进行不正确的类型转换后抛出异常，
在此实例中，代码会在类型转换检查不通过时忽略后续代码来结束整个方法返回结果，
如类型转换成功，其所一并声明的变量也可以在后续的代码中被使用。

[!code-csharp[Casting Inverse Check](samples/casting-negation-check.cs)]

> [!NOTE]
> 在类型转换或类型检查时需使用 `is`、`as` 和 `not` 关键字。
> `==`、`!=` 和 `=` 适用于变量或实例化对象之间，而非它们与类型之间，
> 如要获取变量或实例化对象的类型，请使用 `Object.GetType` 方法或 `typeof` 运算符。
